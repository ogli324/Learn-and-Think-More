# ollvm自定义string加密pass

url：http://missking.cc/2020/10/12/ollvm/

先贴上测试好的结果: https://github.com/dqzg12300/kOLLVM.git

想要写一个字符串加密的pass，第一步就是先实现一遍c++的算法流程，然后再看一看生成的IR文件，然后再写对应的加密pass，下面看一个自己实现的简单c++字符串加密。

```
#include <stdio.h>
#include <cstring>
#include <string>

int main(int  argc, char** argv) {
    //加密
    std::string str1="hello world!!!";
    //这里是随机的key，先写固定,真实实现的时候再每个字节使用一个随机key
    int randkey=11;
      //加密复杂度
    int kstr_size=10;
    int enclen=randkey+kstr_size;
    char encres[str1.size()];
    int idx=0;
    memset(encres,0,enclen);
    //这里大概就是遍历字符串，每个字符根据加密复杂度进行一定数量迭代异或，最后一次的迭代使用取反再异或
    for(int i=0;i<str1.size();i++){
        printf("cur: %x \r\n",str1[i]);
        for(int y=randkey;y<enclen;y++){
            if(y==randkey){
                encres[i]=str1[i]^y;
            }else if(y==enclen-1){
                encres[i]=encres[i]^(~y);
            }else{
                encres[i]=encres[i]^y;
            }
            printf("%x ",encres[i]);
            idx++;
        }
        printf("\r\n");
    }
    printf("encdata: %s\r\n",encres);
    //下面是解密函数
    char decres[str1.size()];
    for(int i=0;i<str1.size();i++){
        printf("cur enc: %x \r\n",encres[i]);
        for(int y=enclen-1;y>=randkey;y--){
            if(y==enclen-1){
                decres[i]=encres[i]^(~y);
            }else{
                decres[i]=decres[i]^y;
            }
            printf("%x ",decres[i]);
        }
        printf("\r\n");
    }
    printf("res: %s\r\n",decres);
    return 0;
}
```

这个简单加密的意思，就是根据复杂度参数。来进行一定次数的迭代，将当前字符每次都异或一下，最后一次是先去反，再异或，解密就是反之。测试结果能正常加密和解密后，我们就先输出一份ir文件。看看在ir中间语言中是如何进行加密和解密的。



```
clang -emit-llvm -S main.cpp -o main.ll
```

生成好对应的ir文件后，我们开始写这个加密pass，然后再写的过程中，根据逻辑需要，去ir中找对应的指令处理方式

在ir文件中的层级划分:Module(模块)的下一层是若干Function(函数),然后在Function的下一层是若干BasicBlock(基本快),再BasicBlock的下一层是若干Instruction(指令块)

现在准备就绪，下面开始先准备一个加密的pass,基本代码如下

```
#include <kllvm/Transforms/Obfuscation/Utils.h>
#include "kllvm/Transforms/Obfuscation/KStringEncode.h"

#include <string>
using namespace llvm;

namespace {
      //加密复杂度
    const int defaultKStringSize = 0x10;
    static cl::opt<int>
            KStringSize("kstr_size", cl::desc("Choose the probability [%] each basic blocks will be obfuscated by the -kstr pass"), cl::value_desc("king string encode Encryption length"), cl::init(defaultKStringSize), cl::Optional);

    struct KStringEncode: public FunctionPass{
        static char ID; // Pass identification
        bool flag;
        KStringEncode() : FunctionPass(ID) {}
        KStringEncode(bool flag) : FunctionPass(ID) {this->flag = flag; KStringEncode();}
        virtual bool runOnFunction(Function &F){
              //先检查加密复杂度是否在合法范围
            if ( !((KStringSize > 0) && (KStringSize <= 100)) ) {
                errs()<<"KStringEncode application basic blocks percentage -kstr_size=x must be 0 < x <= 100";
                return false;
            }
            if(toObfuscate(flag,&F,"kstr")) {
                kstr(F);
            }
            return false;
        }
        void kstr(Function& func){
            //todo 这里再写具体的pass逻辑
        }
    };

}
char KStringEncode::ID = 0;
static RegisterPass<KStringEncode> X("kstr", "inserting bogus control flow");

Pass *llvm::createKStringEncode() {
    return new KStringEncode();
}

Pass *llvm::createKStringEncode(bool flag) {
    return new KStringEncode(flag);
}
```

这里准备好了pass的基本代码后，最后就剩下最重要的核心逻辑，如何把c++的加密方式。在pass中实现，我们的功能是实现字符串加密，那么第一步应该是取得这个函数中的全部字符串，那么我们先看看ir中字符串的特征

```
@.str = private unnamed_addr constant [15 x i8] c"hello world!!!\00", align 1
```

可以看到，这个str是一个操作数，想要获取全部字符串，就得先遍历所有指令块中的操作数。然后再根据字符串的特征来进行过滤。下面先看如何遍历所有指令块。

```
void kstr(Function& func){
            for(BasicBlock& bb:func){
                for(Instruction& ins :bb){
                    for(Value* val:ins.operands()){
                        Value* stripOp=val->stripPointerCasts();
                        if(stripOp->getName().contains(".str")){
                            errs()<<ins<<"\n";
                            errs()<<*val<<"\n";
                            errs()<<*stripOp<<"\n";
                        }
                    }
                }
            }
        }
```

上面遍历了函数中的所有基本快，然后遍历所有指令块，然后遍历所有操作数，然后获取操作数的值，判断该操作数是否是一个字符串，并且打印这个指令块，操作数，以及取到的操作数的值，下面看看打印的结果

```
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0), i8** %str, align 8
i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str, i64 0, i64 0)
@.str = private unnamed_addr constant [7 x i8] c"kanxue\00", align 1
```

那么看到了，我们想获取的字符串是在stripOp中。那么接下来就把所有字符串全部获取出来并转换成string

```
//封装一个转换操作数值为字符串的函数
std::string ConvertOpToString(Value* op){
            GlobalVariable* globalVar= dyn_cast<GlobalVariable>(op);
            if(!globalVar){
                errs()<<"dyn cast gloabl err";
                return "";
            }
            ConstantDataSequential* cds=dyn_cast<ConstantDataSequential>(globalVar->getInitializer());
            if(!cds){
                errs()<<"dyn cast constant data err";
                return "";
            }
            return cds->getRawDataValues();;
        }

        void kstr(Function& func){
            for(BasicBlock& bb:func){
                for(Instruction& ins :bb){
                    for(Value* val:ins.operands()){
                        Value* stripOp=val->stripPointerCasts();
                        if(stripOp->getName().contains(".str")){
                            std::string strdata=ConvertOpToString(stripOp);
                            errs()<<strdata<<"\n";
                        }
                    }
                }
            }
        }
```

之前看到的字符串的ir代码看到所有字符串都是全局的，所以要先转换成全局的对象，然后再转换成数值。然后看这里的打印结果

```
kanxue
hello ollvm:%d
```

获取到所有的字符串了之后。接下来。我们要先把这个字符串加密，然后再用插入指令块来进行解密。下面继续完善，先把之前搞好的加密算法迁移进来。

```
//转换字符串
        std::string ConvertOpToString(Value* op){
            GlobalVariable* globalVar= dyn_cast<GlobalVariable>(op);
            if(!globalVar){
                errs()<<"dyn cast gloabl err";
                return "";
            }
            ConstantDataSequential* cds=dyn_cast<ConstantDataSequential>(globalVar->getInitializer());
            if(!cds){
                errs()<<"dyn cast constant data err";
                return "";
            }
            return cds->getRawDataValues();;
        }

        void kstr(Function& func){
            for(BasicBlock& bb:func){
                for(Instruction& ins :bb){
                    for(Value* val:ins.operands()){
                        Value* stripOp=val->stripPointerCasts();
                        if(stripOp->getName().contains(".str")){
                            std::string strdata=ConvertOpToString(stripOp);
                            errs()<<strdata<<"\n";

                            //加密流程
                            uint8_t keys[strdata.size()];
                            char encres[strdata.size()];
                            int idx=0;
                            memset(encres,0,strdata.size());
                            for(int i=0;i<strdata.size();i++){
                                uint8_t randkey=llvm::cryptoutils->get_uint8_t();
                                keys[i]=randkey;
                                int enclen=randkey+defaultKStringSize;
                                for(int y=randkey;y<enclen;y++){
                                    if(y==randkey){
                                        encres[i]=strdata[i]^y;
                                    }else if(y==enclen-1){
                                        encres[i]=encres[i]^(~y);
                                    }else{
                                        encres[i]=encres[i]^y;
                                    }
                                    idx++;
                                }
                            }
                        }
                    }
                }
            }
        }
```

这里大致流程和之前一样。只是key我们装起来了。然后每个字节处理都随机一次key。接下来的处理就是插入指令块来对这个加密数据encres进行解密还原处理。

我们想要处理这个加密的数据，首先要先创建一个内存指令，来存放这个加密后的数据。然后再对加密后的数据遍历。进行还原。所以，我们的下一步先创建一个BitCastInst。并且我们需要用一个int8的array来给这个内存指令进行赋值。下面的代码是先创建array指令，然后用array指令创建一个内存指令

```
ArrayType* arrType=ArrayType::get(Type::getInt8Ty(func.getContext()),strdata.size());
                            AllocaInst* arrayInst=new AllocaInst(arrType,0,nullptr,1,Twine(stripOp->getName()+".arr"),&ins);
                            BitCastInst* bitInst=new BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()->getContext()),Twine(stripOp->getName()+"bitcast"),&ins);
```

上面的就是先创建一个int8的array类型，然后用这个类型创建一个array，然后再用这个array创建内存指令，这些指令都插入在遍历到字符串指令的当前行的前方。这个bitcast将用来存放加密后的字符串数据

接下来就是解密的逻辑处理。和我们之前c++的流程一样，只不过这里需要换成插入指令块的形式来进行加密数据的还原，我直接贴上解密的代码部分，然后里面有详细的注释。

```
ArrayType* arrType=ArrayType::get(Type::getInt8Ty(func.getContext()),strdata.size());
AllocaInst* arrayInst=new AllocaInst(arrType,0,nullptr,1,Twine(stripOp->getName()+".arr"),&ins);
BitCastInst* bitInst=new BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()->getContext()),Twine(stripOp->getName()+".bitcast"),&ins);
//创建一个对象用来存放当前加密字节解密时每次异或的结果
AllocaInst* eor_res=new AllocaInst(Type::getInt8Ty(func.getContext()),0,nullptr,1,Twine(stripOp->getName()+".alloc.res"),&ins);
for(int i=0;i<strdata.size();i++){
    uint8_t randkey=keys[i];
    int enclen=randkey+defaultKStringSize;
    ConstantInt* enc_const=ConstantInt::get(Type::getInt8Ty(func.getContext()),encres[i]);
    //用来存放解密结果的bitcat
    ConstantInt* i_const=ConstantInt::get(Type::getInt8Ty(func.getContext()),i);
    GetElementPtrInst* element=GetElementPtrInst::CreateInBounds(bitInst,i_const);
    element->insertBefore(&ins);
    StoreInst* last_store=nullptr;
    for(int y=enclen-1;y>=randkey;y--){
        /*下面是获取y的指令块*/
        //先是创建一个数值y
        ConstantInt *eor_data = ConstantInt::get(Type::getInt8Ty(func.getContext()),y);
        //申请一个int8的内存来存放数值y
        AllocaInst* eor_alloc=new AllocaInst(Type::getInt8Ty(func.getContext()),0,nullptr,1,Twine(stripOp->getName()+".alloc.y"),&ins);
        //将数值y赋值给申请的内存空间
        StoreInst* store_eor=new StoreInst(eor_data,eor_alloc);
        store_eor->insertAfter(eor_alloc);
        //从内存空间中加载里面的数值y
        LoadInst* eor_load=new LoadInst(eor_alloc,"");
        eor_load->insertAfter(store_eor);
        //如果是第一次异或
        if(y==enclen-1){
            //然后进行取反计算
            BinaryOperator* binNotOp=BinaryOperator::CreateNot(eor_load);
            binNotOp->insertAfter(eor_load);
              //然后异或
            BinaryOperator* binXorOp=BinaryOperator::CreateXor(enc_const,binNotOp);
            binXorOp->insertAfter(binNotOp);
            //将加密字节设置为上次异或的结果
            StoreInst* store_eor_res=new StoreInst(binXorOp,eor_res);
            store_eor_res->insertAfter(store_data);
        }else{
            //加载获取上次异或的结果
            LoadInst* eor_load_res=new LoadInst(eor_res,stripOp->getName()+".load");
            eor_load_res->insertAfter(store_eor);
            //然后再进行异或计算
            BinaryOperator* binXorOp=BinaryOperator::CreateXor(eor_load_res,eor_load);
            binXorOp->insertAfter(eor_load);
            //将计算后的结果存放回数组中
            StoreInst* store_data=new StoreInst(binXorOp,eor_res);
            store_data->insertAfter(binXorOp);
            //当循环到最后一次时，获取一下最后一次赋值的指令块地址。方便后面接着往后插指令块
            if(y==randkey){
                last_store=store_data;
            }
        }
    }
      //读取这个字节经过多次异或后的最终结果
    LoadInst* dec_res=new LoadInst(eor_res,stripOp->getName()+".dec.res");
    dec_res->insertAfter(last_store);
    //将这个结果写入到前面用来存放的解密结果bitcat处
    StoreInst* store_data=new StoreInst(dec_res,element);
    store_data->insertAfter(dec_res);
}
```

上面就是把c++的解密流程用插入指令块的方式实现的方式。流程比较繁琐，但是大概意思是差不多的。

最后这里完成后，我们就可以删除指令块中的字符串明文部分。然后只保留密文

```
//将字符串操作数替换为我们准备好的解密结果的bitInst
val->replaceAllUsesWith(bitInst);
//然后再删掉之前我们获取到的字符串的明文部分。这样就只有密文数据和密文解密的流程，最后动态执行拿到解密字符串了
GlobalVariable* globalVar= dyn_cast<GlobalVariable>(stripOp);
globalVar->eraseFromParent();
```

到这里整个流程就完成了。这里还有一个点需要注意的是，由于字符串的特性，当使用了多个相同的字符串，实际在汇编层的代码中，会优化为一个字符串，所以在字符串加密的时候，我们要留意解密字符串的作用域。下面举一个例子

```
int main(int  argc, char** argv) {
    int a = argc;
    if(a == 0)
        printf("hello");
    else
        printf("hello");
    return 0;
}
```

这个例子中使用了两个hello。如果我们在使用这个字符串时，调用的解密。那么下面else中的代码则会无法访问到bitcat。因为不在同一个作用域，所以为了防止出现这种情况，我在解密时再做一个特殊的处理，我们先获取第一个指令块的位置，然后所有的字符串解密指令块，都插入在最开始的位置，这样就不会出现作用域的问题了。最后贴上完整代码

```
//
// Created by king on 2020/10/7.
//

#include <kllvm/Transforms/Obfuscation/Utils.h>
#include "kllvm/Transforms/Obfuscation/KStringEncode.h"

#include <string>
using namespace llvm;

namespace {
    const int defaultKStringSize = 0x3;
    static cl::opt<int>
            KStringSize("kstr_size", cl::desc("Choose the probability [%] each basic blocks will be obfuscated by the -kstr pass"), cl::value_desc("king string encode Encryption length"), cl::init(defaultKStringSize), cl::Optional);

    struct KStringEncode: public FunctionPass{
        static char ID; // Pass identification
        bool flag;
        KStringEncode() : FunctionPass(ID) {}
        KStringEncode(bool flag) : FunctionPass(ID) {this->flag = flag; KStringEncode();}
        virtual bool runOnFunction(Function &F){
            if ( !((KStringSize > 0) && (KStringSize <= 0x20)) ) {
                errs()<<"KStringEncode application basic blocks percentage -kstr_size=x must be 0 < x <= 100";
                return false;
            }
            if(toObfuscate(flag,&F,"kstr")) {
                kstr(F);
//                printFunction(F);

                return true;
            }
            return false;
        }
        //转换字符串
        std::string ConvertOpToString(Value* op){
            GlobalVariable* globalVar= dyn_cast<GlobalVariable>(op);
            if(!globalVar){
                errs()<<"dyn cast gloabl err";
                return "";
            }
            ConstantDataSequential* cds=dyn_cast<ConstantDataSequential>(globalVar->getInitializer());
            if(!cds){
                errs()<<"dyn cast constant data err";
                return "";
            }
            return cds->getRawDataValues();;
        }

        void kstr(Function& func){
            Instruction* begin_ins=nullptr;
            for(BasicBlock& bb:func){
                for(Instruction& ins :bb){
                    if(begin_ins==nullptr){
                        begin_ins=&ins;
                    }
                    for(Value* val:ins.operands()){
                        Value* stripOp=val->stripPointerCasts();
                        if(stripOp->getName().contains(".str")){
                            std::string strdata=ConvertOpToString(stripOp);
                            errs()<<strdata<<"\n";
                            if(strdata.size()<=0){
                                continue;
                            }
                            //加密流程
                            uint8_t keys[strdata.size()];
                            char encres[strdata.size()];
                            int idx=0;
                            memset(encres,0,strdata.size());
                            for(int i=0;i<strdata.size();i++){
                                uint8_t randkey=llvm::cryptoutils->get_uint8_t();
                                keys[i]=randkey;
                                int enclen=randkey+defaultKStringSize;
                                for(int y=randkey;y<enclen;y++){
                                    if(y==randkey){
                                        encres[i]=strdata[i]^y;
                                    }else if(y==enclen-1){
                                        encres[i]=encres[i]^(~y);
                                    }else{
                                        encres[i]=encres[i]^y;
                                    }
                                    printf("%x ",encres[i]);
                                    idx++;
                                }
                            }
                            ArrayType* arrType=ArrayType::get(Type::getInt8Ty(func.getContext()),strdata.size());
                            AllocaInst* arrayInst=new AllocaInst(arrType,0,nullptr,1,Twine(stripOp->getName()+".arr"),begin_ins);
                            BitCastInst* bitInst=new BitCastInst(arrayInst,Type::getInt8PtrTy(func.getParent()->getContext()),Twine(stripOp->getName()+".bitcast"),begin_ins);
                            //创建一个对象用来存放当前加密字节解密时每次异或的结果
                            AllocaInst* eor_res=new AllocaInst(Type::getInt8Ty(func.getContext()),0,nullptr,1,Twine(stripOp->getName()+".alloc.res"),begin_ins);
                            for(int i=0;i<strdata.size();i++){
                                uint8_t randkey=keys[i];
                                int enclen=randkey+defaultKStringSize;
                                ConstantInt* enc_const=ConstantInt::get(Type::getInt8Ty(func.getContext()),encres[i]);
                                //用来存放解密结果的bitcat
                                ConstantInt* i_const=ConstantInt::get(Type::getInt8Ty(func.getContext()),i);
                                GetElementPtrInst* element=GetElementPtrInst::CreateInBounds(bitInst,i_const);
                                element->insertBefore(begin_ins);
                                StoreInst* last_store=nullptr;
                                for(int y=enclen-1;y>=randkey;y--){
                                    /*下面是获取y的指令块*/
                                    //先是创建一个数值y
                                    ConstantInt *eor_data = ConstantInt::get(Type::getInt8Ty(func.getContext()),y);
                                    //申请一个int8的内存来存放数值y
                                    AllocaInst* eor_alloc=new AllocaInst(Type::getInt8Ty(func.getContext()),0,nullptr,1,Twine(stripOp->getName()+".alloc.y"),begin_ins);
                                    //将数值y赋值给申请的内存空间
                                    StoreInst* store_eor=new StoreInst(eor_data,eor_alloc);
                                    store_eor->insertAfter(eor_alloc);
                                    //从内存空间中加载里面的数值y
                                    LoadInst* eor_load=new LoadInst(eor_alloc,"");
                                    eor_load->insertAfter(store_eor);
                                    //
                                    if(y==enclen-1){
                                        //然后进行取反计算
                                        BinaryOperator* binNotOp=BinaryOperator::CreateNot(eor_load);
                                        binNotOp->insertAfter(eor_load);
                                        //然后异或
                                        BinaryOperator* binXorOp=BinaryOperator::CreateXor(enc_const,binNotOp);
                                        binXorOp->insertAfter(binNotOp);
                                        //将加密字节设置为上次异或的结果
                                        StoreInst* store_eor_res=new StoreInst(binXorOp,eor_res);
                                        store_eor_res->insertAfter(binXorOp);
                                    }else{
                                        LoadInst* eor_load_res=new LoadInst(eor_res,stripOp->getName()+".load");
                                        eor_load_res->insertAfter(store_eor);
                                        //然后进行异或计算
                                        BinaryOperator* binXorOp=BinaryOperator::CreateXor(eor_load_res,eor_load);
                                        binXorOp->insertAfter(eor_load);
                                        //将计算后的结果存放回数组中
                                        StoreInst* store_data=new StoreInst(binXorOp,eor_res);
                                        store_data->insertAfter(binXorOp);
                                        if(y==randkey){
                                            last_store=store_data;
                                        }
                                    }
                                }
                                //读取这个字节经过多次异或后的最终结果
                                LoadInst* dec_res=new LoadInst(eor_res,stripOp->getName()+".dec.res");
                                dec_res->insertAfter(last_store);
                                //将这个结果写入到前面用来存放的解密结果bitcat处
                                StoreInst* store_data=new StoreInst(dec_res,element);
                                store_data->insertAfter(dec_res);
                            }
                            //将字符串操作数替换为我们准备好的解密结果的bitInst
                            val->replaceAllUsesWith(bitInst);
                            //然后再删掉之前我们获取到的字符串的明文部分。这样就只有密文数据和密文解密的流程，最后动态执行拿到解密字符串了
                            GlobalVariable* globalVar= dyn_cast<GlobalVariable>(stripOp);
                            globalVar->eraseFromParent();

                        }
                    }
                }
            }
        }
    };

}
char KStringEncode::ID = 0;
static RegisterPass<KStringEncode> X("kstr", "inserting bogus control flow");

Pass *llvm::createKStringEncode() {
    return new KStringEncode();
}

Pass *llvm::createKStringEncode(bool flag) {
    return new KStringEncode(flag);
}
```

最后我们来执行测试一下,执行下面的命令使用这个pass进行加密

```
clang -Xclang -load -Xclang /mnt/hgfs/kali_share/kOLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -kstr -mllvm -kstr_size=10 -emit-llvm -S main.cpp -o main_ollvm_kstr.ll
```

检查下这个ir文件没啥问题。那么编译成二进制。

```
clang main_ollvm_kstr.ll -o main
```

接着我们再用ida打开看看这个二进制文件的main函数里面的字符串是否已经被混淆了

先看看测试混淆的目标代码

```
int main(int argc, char const *argv[])
{
    char* str = "kanxue";
    int n = argc;
    if (n >= 2) {
        printf("hello ollvm:%d\r\n", n);
    } else {
        printf("%s", str);
    }
    return 0;
}
```

然后再看看混淆后，使用ida打开的结果

```
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+3Bh] [rbp-65h]
  char v5; // [rsp+3Ch] [rbp-64h]
  char v6; // [rsp+3Dh] [rbp-63h]
  char v7; // [rsp+3Eh] [rbp-62h]
  char v8; // [rsp+3Fh] [rbp-61h]
  char v9; // [rsp+40h] [rbp-60h]
  char v10; // [rsp+41h] [rbp-5Fh]
  char v11; // [rsp+42h] [rbp-5Eh]
  char v12; // [rsp+43h] [rbp-5Dh]
  char v13; // [rsp+44h] [rbp-5Ch]
  char v14; // [rsp+45h] [rbp-5Bh]
  char v15; // [rsp+46h] [rbp-5Ah]
  char v16; // [rsp+47h] [rbp-59h]
  char v17; // [rsp+48h] [rbp-58h]
  char v18; // [rsp+49h] [rbp-57h]
  char v19; // [rsp+4Ah] [rbp-56h]
  char v20; // [rsp+4Bh] [rbp-55h]
  char v21; // [rsp+4Ch] [rbp-54h]
  char v22; // [rsp+4Dh] [rbp-53h]
  char v23; // [rsp+4Eh] [rbp-52h]
  char v24; // [rsp+4Fh] [rbp-51h]
  char v25; // [rsp+50h] [rbp-50h]
  char v26; // [rsp+51h] [rbp-4Fh]
  char v27; // [rsp+52h] [rbp-4Eh]
  char v28; // [rsp+53h] [rbp-4Dh]
  char v29; // [rsp+54h] [rbp-4Ch]
  char v30; // [rsp+55h] [rbp-4Bh]
  char v31; // [rsp+56h] [rbp-4Ah]
  char v32; // [rsp+57h] [rbp-49h]
  char v33; // [rsp+58h] [rbp-48h]
  char v34; // [rsp+59h] [rbp-47h]
  char v35; // [rsp+5Ah] [rbp-46h]
  char v36; // [rsp+5Bh] [rbp-45h]
  char v37; // [rsp+5Ch] [rbp-44h]
  char v38; // [rsp+5Dh] [rbp-43h]
  char v39; // [rsp+5Eh] [rbp-42h]
  char v40; // [rsp+5Fh] [rbp-41h]
  char v41; // [rsp+60h] [rbp-40h]
  char v42; // [rsp+61h] [rbp-3Fh]
  char v43; // [rsp+62h] [rbp-3Eh]
  char v44; // [rsp+63h] [rbp-3Dh]
  char v45; // [rsp+64h] [rbp-3Ch]
  char v46; // [rsp+65h] [rbp-3Bh]
  char v47; // [rsp+66h] [rbp-3Ah]
  char v48; // [rsp+67h] [rbp-39h]
  char v49; // [rsp+68h] [rbp-38h]
  char v50; // [rsp+69h] [rbp-37h]
  char v51; // [rsp+6Ah] [rbp-36h]
  char v52; // [rsp+6Bh] [rbp-35h]
  char v53; // [rsp+6Ch] [rbp-34h]
  char v54; // [rsp+6Dh] [rbp-33h]
  char v55; // [rsp+6Eh] [rbp-32h]
  char v56; // [rsp+6Fh] [rbp-31h]
  char v57; // [rsp+70h] [rbp-30h]
  char v58; // [rsp+71h] [rbp-2Fh]
  char v59; // [rsp+72h] [rbp-2Eh]
  char v60; // [rsp+73h] [rbp-2Dh]
  char v61; // [rsp+74h] [rbp-2Ch]
  char v62; // [rsp+75h] [rbp-2Bh]
  char v63; // [rsp+76h] [rbp-2Ah]
  char v64; // [rsp+77h] [rbp-29h]
  char v65; // [rsp+78h] [rbp-28h]
  char v66; // [rsp+79h] [rbp-27h]
  char v67; // [rsp+7Ah] [rbp-26h]
  char v68; // [rsp+7Bh] [rbp-25h]
  char v69; // [rsp+7Ch] [rbp-24h]
  char v70; // [rsp+7Dh] [rbp-23h]
  char v71; // [rsp+7Eh] [rbp-22h]
  char v72; // [rsp+7Fh] [rbp-21h]
  char v73; // [rsp+80h] [rbp-20h]
  char v74; // [rsp+81h] [rbp-1Fh]
  char v75; // [rsp+82h] [rbp-1Eh]
  char v76; // [rsp+83h] [rbp-1Dh]
  char v77; // [rsp+84h] [rbp-1Ch]
  char v78; // [rsp+85h] [rbp-1Bh]
  char v79; // [rsp+86h] [rbp-1Ah]
  char v80; // [rsp+87h] [rbp-19h]
  char v81; // [rsp+88h] [rbp-18h]
  char v82; // [rsp+89h] [rbp-17h]
  char v83; // [rsp+8Ah] [rbp-16h]
  char v84; // [rsp+8Bh] [rbp-15h]
  char v85; // [rsp+8Ch] [rbp-14h]
  char v86; // [rsp+8Dh] [rbp-13h]
  char v87; // [rsp+8Eh] [rbp-12h]
  char v88; // [rsp+8Fh] [rbp-11h]
  char v89; // [rsp+90h] [rbp-10h]
  char v90; // [rsp+91h] [rbp-Fh]
  char v91; // [rsp+92h] [rbp-Eh]
  char v92; // [rsp+93h] [rbp-Dh]
  char v93; // [rsp+94h] [rbp-Ch]
  char v94; // [rsp+95h] [rbp-Bh]
  char v95; // [rsp+96h] [rbp-Ah]
  char v96; // [rsp+97h] [rbp-9h]
  char v97; // [rsp+98h] [rbp-8h]
  char v98; // [rsp+99h] [rbp-7h]
  char v99; // [rsp+9Ah] [rbp-6h]
  char v100; // [rsp+9Bh] [rbp-5h]
  char v101; // [rsp+9Ch] [rbp-4h]
  char v102; // [rsp+9Dh] [rbp-3h]
  char v103; // [rsp+9Eh] [rbp-2h]
  char v104; // [rsp+9Fh] [rbp-1h]

  v96 = 94;
  v95 = 93;
  v94 = 92;
  v98 = 107;
  v93 = 237;
  v92 = 236;
  v91 = 235;
  v99 = 97;
  v90 = 122;
  v89 = 121;
  v88 = 120;
  v100 = 110;
  v87 = 129;
  v86 = 128;
  v85 = 127;
  v101 = 120;
  v84 = -55;
  v83 = -56;
  v82 = -57;
  v102 = 117;
  v81 = -100;
  v80 = -101;
  v79 = -102;
  v103 = 101;
  v78 = 87;
  v77 = 86;
  v76 = 85;
  v97 = 0;
  v104 = 0;
  v57 = -104;
  v56 = -105;
  v55 = -106;
  v59 = 104;
  v54 = 73;
  v53 = 72;
  v52 = 71;
  v60 = 101;
  v51 = -109;
  v50 = -110;
  v49 = -111;
  v61 = 108;
  v48 = 42;
  v47 = 41;
  v46 = 40;
  v62 = 108;
  v45 = -81;
  v44 = -82;
  v43 = -83;
  v63 = 111;
  v42 = -78;
  v41 = -79;
  v40 = -80;
  v64 = 32;
  v39 = -116;
  v38 = -117;
  v37 = -118;
  v65 = 111;
  v36 = 99;
  v35 = 98;
  v34 = 97;
  v66 = 108;
  v33 = 12;
  v32 = 11;
  v31 = 10;
  v67 = 108;
  v30 = 95;
  v29 = 94;
  v28 = 93;
  v68 = 118;
  v27 = 9;
  v26 = 8;
  v25 = 7;
  v69 = 109;
  v24 = 26;
  v23 = 25;
  v22 = 24;
  v70 = 58;
  v21 = 109;
  v20 = 108;
  v19 = 107;
  v71 = 37;
  v18 = 92;
  v17 = 91;
  v16 = 90;
  v72 = 100;
  v15 = -50;
  v14 = -51;
  v13 = -52;
  v73 = 13;
  v12 = 119;
  v11 = 118;
  v10 = 117;
  v74 = 10;
  v9 = 4;
  v8 = 3;
  v7 = 2;
  v58 = 0;
  v75 = 0;
  v4 = '%';
  v5 = 's';
  v6 = 0;
  if ( argc < 2 )
    printf(&v4, &v98, &v4);
  else
    printf(&v59, (unsigned int)argc, &v4);
  return 0;
}
```

尽管看起来好像已经混淆成功了，但是实际上依然可以看到ida给我们自动解析了很多，字符串基本被还原了一些，比如找到&98然后往后的几个字节存放的就已经是明文了。这里我们只要再加一层混淆。让代码的结构更加混乱。ida就无法自动还原出我们的字符串明文了。再增加一些参数混淆下。

```
clang -Xclang -load -Xclang /mnt/hgfs/kali_share/kOLLVM/cmake-build-debug/ollvm/lib/Transforms/Obfuscation/LLVMObfuscation.so -mllvm -kstr -mllvm -kstr_size=10 -mllvm -bcf -mllvm -bcf_loop=3 -mllvm -fla -emit-llvm -S main.cpp -o main_ollvm_kstr.ll
```